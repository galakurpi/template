import { S as SvelteComponent, i as init, s as safe_not_equal, z as add_render_callback, e as element, a as space, t as text, b as attr, A as set_style, m as toggle_class, c as insert, d as append, l as listen, j as set_data, n as noop, f as detach, g as component_subscribe, k as t, p as onMount, B as globals, C as binding_callbacks, D as destroy_each, u as create_component, v as mount_component, w as transition_in, x as transition_out, y as destroy_component } from './i18n-b2e39bd5.js';
import { P as PublicNavbar } from './PublicNavbar-1f5397ba.js';
import { F as Footer } from './footer-9e393caa.js';

/* src\landing\LandingComponents\HeroSection.svelte generated by Svelte v3.59.2 */

const { window: window_1$2 } = globals;

function create_fragment$5(ctx) {
	let scrolling = false;

	let clear_scrolling = () => {
		scrolling = false;
	};

	let scrolling_timeout;
	let section;
	let canvas_1;
	let t0;
	let div2;
	let div1;
	let h1;
	let t1_value = (/*$t*/ ctx[4].features?.landing?.hero?.title || 'AI Automation for Real Business Results') + "";
	let t1;
	let t2;
	let p;
	let t3_value = (/*$t*/ ctx[4].features?.landing?.hero?.subtitle || 'Practical AI solutions that save time, reduce costs, and drive growth') + "";
	let t3;
	let t4;
	let div0;
	let a;
	let t5_value = (/*$t*/ ctx[4].features?.landing?.hero?.primaryButton || 'Contact Us') + "";
	let t5;
	let mounted;
	let dispose;
	add_render_callback(/*onwindowscroll*/ ctx[5]);

	return {
		c() {
			section = element("section");
			canvas_1 = element("canvas");
			t0 = space();
			div2 = element("div");
			div1 = element("div");
			h1 = element("h1");
			t1 = text(t1_value);
			t2 = space();
			p = element("p");
			t3 = text(t3_value);
			t4 = space();
			div0 = element("div");
			a = element("a");
			t5 = text(t5_value);
			attr(canvas_1, "class", "geometric-bg svelte-w5umcd");
			attr(h1, "class", "reveal-element svelte-w5umcd");
			set_style(h1, "transform", "translateY(" + /*scrollY*/ ctx[1] * 0.2 + "px)");
			attr(p, "class", "subtitle reveal-element svelte-w5umcd");
			set_style(p, "transform", "translateY(" + /*scrollY*/ ctx[1] * 0.2 + "px)");
			attr(a, "href", "/landing/contact/");
			attr(a, "class", "btn btn-primary svelte-w5umcd");
			attr(div0, "class", "cta-buttons reveal-element svelte-w5umcd");
			set_style(div0, "transform", "translateY(" + /*scrollY*/ ctx[1] * 0.2 + "px)");
			attr(div1, "class", "hero-content svelte-w5umcd");
			attr(div2, "class", "container");
			attr(section, "id", "hero");
			attr(section, "class", "hero-section svelte-w5umcd");
			toggle_class(section, "visible", /*sectionVisible*/ ctx[0]['hero'] || false);
		},
		m(target, anchor) {
			insert(target, section, anchor);
			append(section, canvas_1);
			/*canvas_1_binding*/ ctx[6](canvas_1);
			append(section, t0);
			append(section, div2);
			append(div2, div1);
			append(div1, h1);
			append(h1, t1);
			append(div1, t2);
			append(div1, p);
			append(p, t3);
			append(div1, t4);
			append(div1, div0);
			append(div0, a);
			append(a, t5);
			/*section_binding*/ ctx[7](section);

			if (!mounted) {
				dispose = listen(window_1$2, "scroll", () => {
					scrolling = true;
					clearTimeout(scrolling_timeout);
					scrolling_timeout = setTimeout(clear_scrolling, 100);
					/*onwindowscroll*/ ctx[5]();
				});

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (dirty & /*scrollY*/ 2 && !scrolling) {
				scrolling = true;
				clearTimeout(scrolling_timeout);
				scrollTo(window_1$2.pageXOffset, /*scrollY*/ ctx[1]);
				scrolling_timeout = setTimeout(clear_scrolling, 100);
			}

			if (dirty & /*$t*/ 16 && t1_value !== (t1_value = (/*$t*/ ctx[4].features?.landing?.hero?.title || 'AI Automation for Real Business Results') + "")) set_data(t1, t1_value);

			if (dirty & /*scrollY*/ 2) {
				set_style(h1, "transform", "translateY(" + /*scrollY*/ ctx[1] * 0.2 + "px)");
			}

			if (dirty & /*$t*/ 16 && t3_value !== (t3_value = (/*$t*/ ctx[4].features?.landing?.hero?.subtitle || 'Practical AI solutions that save time, reduce costs, and drive growth') + "")) set_data(t3, t3_value);

			if (dirty & /*scrollY*/ 2) {
				set_style(p, "transform", "translateY(" + /*scrollY*/ ctx[1] * 0.2 + "px)");
			}

			if (dirty & /*$t*/ 16 && t5_value !== (t5_value = (/*$t*/ ctx[4].features?.landing?.hero?.primaryButton || 'Contact Us') + "")) set_data(t5, t5_value);

			if (dirty & /*scrollY*/ 2) {
				set_style(div0, "transform", "translateY(" + /*scrollY*/ ctx[1] * 0.2 + "px)");
			}

			if (dirty & /*sectionVisible*/ 1) {
				toggle_class(section, "visible", /*sectionVisible*/ ctx[0]['hero'] || false);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(section);
			/*canvas_1_binding*/ ctx[6](null);
			/*section_binding*/ ctx[7](null);
			mounted = false;
			dispose();
		}
	};
}

function instance$5($$self, $$props, $$invalidate) {
	let $t;
	component_subscribe($$self, t, $$value => $$invalidate(4, $t = $$value));
	let { sectionVisible = {} } = $$props;
	let scrollY = 0;

	// Function to initialize the animated geometric background
	let canvas;

	let ctx;
	let sectionElement;

	onMount(() => {
		if (typeof window !== 'undefined') {
			initGeometricBackground();
			window.addEventListener('resize', initGeometricBackground);

			return () => {
				window.removeEventListener('resize', initGeometricBackground);

				if (ctx && ctx.canvas) {
					ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
				}
			};
		}

		// Force a reflow to ensure the reveal elements are properly initialized
		const revealElements = sectionElement.querySelectorAll('.reveal-element');

		console.log('HeroSection reveal elements:', revealElements.length);

		// Force a reflow to ensure CSS transitions work properly
		revealElements.forEach(el => {
			// This forces a reflow
			void el.offsetHeight;
		});
	});

	function initGeometricBackground() {
		if (!canvas) return;
		const dpr = window.devicePixelRatio || 1;
		$$invalidate(2, canvas.width = window.innerWidth * dpr, canvas);
		$$invalidate(2, canvas.height = window.innerHeight * dpr, canvas);
		ctx = canvas.getContext('2d');
		if (!ctx) return;
		ctx.scale(dpr, dpr);

		// Set canvas dimensions in CSS
		$$invalidate(2, canvas.style.width = window.innerWidth + 'px', canvas);

		$$invalidate(2, canvas.style.height = window.innerHeight + 'px', canvas);

		// Clear previous drawings
		ctx.clearRect(0, 0, canvas.width, canvas.height);

		// Create geometric shapes
		const lines = [];

		const nodeCount = Math.floor(window.innerWidth / 200) + 8; // Fewer nodes, more stable

		// Create nodes (points)
		const nodes = [];

		for (let i = 0; i < nodeCount; i++) {
			nodes.push({
				x: Math.random() * window.innerWidth,
				y: Math.random() * window.innerHeight,
				vx: (Math.random() - 0.5) * 0.15, // Slower movement
				vy: (Math.random() - 0.5) * 0.15
			});
		}

		// Create connections between more nodes
		for (let i = 0; i < nodes.length; i++) {
			const connectionsCount = Math.floor(Math.random() * 2) + 2; // 2-3 connections per node

			for (let j = 0; j < connectionsCount; j++) {
				const targetIndex = Math.floor(Math.random() * nodes.length);

				if (targetIndex !== i) {
					lines.push({
						start: nodes[i],
						end: nodes[targetIndex],
						opacity: Math.random() * 0.4 + 0.3, // More consistent opacity
						pulseDirection: Math.random() > 0.5 ? 1 : -1,
						pulseSpeed: Math.random() * 0.005 + 0.001, // Slower pulse for less appearing/disappearing
						
					});
				}
			}
		}

		// Add some random standalone lines for visual interest
		for (let i = 0; i < nodeCount / 4; i++) {
			const x1 = Math.random() * window.innerWidth;
			const y1 = Math.random() * window.innerHeight;
			const length = Math.random() * 80 + 30; // Smaller line length
			const angle = Math.random() * Math.PI * 2;

			const startNode = {
				x: x1,
				y: y1,
				vx: (Math.random() - 0.5) * 0.05, // Much slower movement
				vy: (Math.random() - 0.5) * 0.05
			};

			const endNode = {
				x: x1 + Math.cos(angle) * length,
				y: y1 + Math.sin(angle) * length,
				vx: (Math.random() - 0.5) * 0.05,
				vy: (Math.random() - 0.5) * 0.05
			};

			lines.push({
				start: startNode,
				end: endNode,
				opacity: Math.random() * 0.4 + 0.3,
				pulseDirection: Math.random() > 0.5 ? 1 : -1,
				pulseSpeed: Math.random() * 0.005 + 0.001
			});

			nodes.push(startNode, endNode);
		}

		// Draw and animate
		function draw() {
			if (!ctx) return;

			// Clear canvas
			ctx.clearRect(0, 0, canvas.width, canvas.height);

			// Draw lines
			lines.forEach(line => {
				if (!ctx) return;

				// Update opacity for pulsing effect
				line.opacity += line.pulseSpeed * line.pulseDirection;

				if (line.opacity > 0.7) {
					line.opacity = 0.7;
					line.pulseDirection = -1;
				} else if (line.opacity < 0.2) {
					// Higher minimum opacity for less disappearing
					line.opacity = 0.2;

					line.pulseDirection = 1;
				}

				ctx.beginPath();
				ctx.strokeStyle = `rgba(239, 200, 36, ${line.opacity})`;
				ctx.lineWidth = 0.5; // Thinner lines
				ctx.moveTo(line.start.x, line.start.y);
				ctx.lineTo(line.end.x, line.end.y);
				ctx.stroke();
			});

			// Move nodes
			nodes.forEach(node => {
				node.x += node.vx;
				node.y += node.vy;

				// Bounce off edges with less speed change
				if (node.x < 0 || node.x > window.innerWidth) {
					node.vx *= -0.95; // Slightly reduce speed on bounce
					node.x = node.x < 0 ? 0 : window.innerWidth;
				}

				if (node.y < 0 || node.y > window.innerHeight) {
					node.vy *= -0.95;
					node.y = node.y < 0 ? 0 : window.innerHeight;
				}
			});

			requestAnimationFrame(draw);
		}

		draw();
	}

	function onwindowscroll() {
		$$invalidate(1, scrollY = window_1$2.pageYOffset);
	}

	function canvas_1_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			canvas = $$value;
			$$invalidate(2, canvas);
		});
	}

	function section_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			sectionElement = $$value;
			$$invalidate(3, sectionElement);
		});
	}

	$$self.$$set = $$props => {
		if ('sectionVisible' in $$props) $$invalidate(0, sectionVisible = $$props.sectionVisible);
	};

	return [
		sectionVisible,
		scrollY,
		canvas,
		sectionElement,
		$t,
		onwindowscroll,
		canvas_1_binding,
		section_binding
	];
}

class HeroSection extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$5, create_fragment$5, safe_not_equal, { sectionVisible: 0 });
	}
}

/* src\landing\LandingComponents\BenefitsSection.svelte generated by Svelte v3.59.2 */

function get_each_context$2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[4] = list[i];
	child_ctx[6] = i;
	return child_ctx;
}

// (25:6) {#each ($t.features?.landing?.benefits?.items || []) as benefit, i}
function create_each_block$2(ctx) {
	let div1;
	let div0;
	let h3;
	let t0_value = /*benefit*/ ctx[4].title + "";
	let t0;
	let t1;
	let p;
	let t2_value = /*benefit*/ ctx[4].description + "";
	let t2;
	let t3;

	return {
		c() {
			div1 = element("div");
			div0 = element("div");
			h3 = element("h3");
			t0 = text(t0_value);
			t1 = space();
			p = element("p");
			t2 = text(t2_value);
			t3 = space();
			attr(h3, "class", "svelte-1a1yyrs");
			attr(p, "class", "svelte-1a1yyrs");
			attr(div0, "class", "benefit-content svelte-1a1yyrs");
			attr(div1, "class", "benefit-card reveal-element svelte-1a1yyrs");
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, div0);
			append(div0, h3);
			append(h3, t0);
			append(div0, t1);
			append(div0, p);
			append(p, t2);
			append(div1, t3);
		},
		p(ctx, dirty) {
			if (dirty & /*$t*/ 2 && t0_value !== (t0_value = /*benefit*/ ctx[4].title + "")) set_data(t0, t0_value);
			if (dirty & /*$t*/ 2 && t2_value !== (t2_value = /*benefit*/ ctx[4].description + "")) set_data(t2, t2_value);
		},
		d(detaching) {
			if (detaching) detach(div1);
		}
	};
}

function create_fragment$4(ctx) {
	let section;
	let div1;
	let h2;
	let t0_value = (/*$t*/ ctx[1].features?.landing?.benefits?.title || 'Why Choose AI Automation?') + "";
	let t0;
	let t1;
	let p;
	let t2_value = (/*$t*/ ctx[1].features?.landing?.benefits?.description || 'Our AI solutions provide tangible benefits that impact your bottom line') + "";
	let t2;
	let t3;
	let div0;
	let each_value = /*$t*/ ctx[1].features?.landing?.benefits?.items || [];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
	}

	return {
		c() {
			section = element("section");
			div1 = element("div");
			h2 = element("h2");
			t0 = text(t0_value);
			t1 = space();
			p = element("p");
			t2 = text(t2_value);
			t3 = space();
			div0 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(h2, "class", "reveal-element svelte-1a1yyrs");
			attr(p, "class", "section-description reveal-element svelte-1a1yyrs");
			attr(div0, "class", "benefits-list svelte-1a1yyrs");
			attr(div1, "class", "container");
			attr(section, "id", "benefits");
			attr(section, "class", "benefits-section svelte-1a1yyrs");
		},
		m(target, anchor) {
			insert(target, section, anchor);
			append(section, div1);
			append(div1, h2);
			append(h2, t0);
			append(div1, t1);
			append(div1, p);
			append(p, t2);
			append(div1, t3);
			append(div1, div0);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(div0, null);
				}
			}

			/*section_binding*/ ctx[3](section);
		},
		p(ctx, [dirty]) {
			if (dirty & /*$t*/ 2 && t0_value !== (t0_value = (/*$t*/ ctx[1].features?.landing?.benefits?.title || 'Why Choose AI Automation?') + "")) set_data(t0, t0_value);
			if (dirty & /*$t*/ 2 && t2_value !== (t2_value = (/*$t*/ ctx[1].features?.landing?.benefits?.description || 'Our AI solutions provide tangible benefits that impact your bottom line') + "")) set_data(t2, t2_value);

			if (dirty & /*$t*/ 2) {
				each_value = /*$t*/ ctx[1].features?.landing?.benefits?.items || [];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$2(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$2(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div0, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(section);
			destroy_each(each_blocks, detaching);
			/*section_binding*/ ctx[3](null);
		}
	};
}

function instance$4($$self, $$props, $$invalidate) {
	let $t;
	component_subscribe($$self, t, $$value => $$invalidate(1, $t = $$value));
	let { sectionVisible = {} } = $$props;
	let sectionElement;

	// We no longer need the scroll-based animation since we're using Intersection Observer
	// Add onMount to ensure elements are properly initialized
	onMount(() => {
		// Force a reflow to ensure the reveal elements are properly initialized
		const revealElements = sectionElement.querySelectorAll('.reveal-element');

		console.log('BenefitsSection reveal elements:', revealElements.length);

		// Force a reflow to ensure CSS transitions work properly
		revealElements.forEach(el => {
			// This forces a reflow
			void el.offsetHeight;
		});
	});

	function section_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			sectionElement = $$value;
			$$invalidate(0, sectionElement);
		});
	}

	$$self.$$set = $$props => {
		if ('sectionVisible' in $$props) $$invalidate(2, sectionVisible = $$props.sectionVisible);
	};

	return [sectionElement, $t, sectionVisible, section_binding];
}

class BenefitsSection extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$4, create_fragment$4, safe_not_equal, { sectionVisible: 2 });
	}
}

/* src\landing\LandingComponents\ProcessSection.svelte generated by Svelte v3.59.2 */

const { window: window_1$1 } = globals;

function get_each_context$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[8] = list[i];
	child_ctx[10] = i;
	return child_ctx;
}

// (62:6) {#each ($t.features?.landing?.process?.steps || []) as step, i}
function create_each_block$1(ctx) {
	let div3;
	let div2;
	let div0;
	let t0_value = /*step*/ ctx[8].number + "";
	let t0;
	let t1;
	let div1;
	let h3;
	let t2_value = /*step*/ ctx[8].title + "";
	let t2;
	let t3;
	let p;
	let t4_value = /*step*/ ctx[8].description + "";
	let t4;
	let t5;

	return {
		c() {
			div3 = element("div");
			div2 = element("div");
			div0 = element("div");
			t0 = text(t0_value);
			t1 = space();
			div1 = element("div");
			h3 = element("h3");
			t2 = text(t2_value);
			t3 = space();
			p = element("p");
			t4 = text(t4_value);
			t5 = space();
			attr(div0, "class", "step-number svelte-8ydegp");
			attr(h3, "class", "svelte-8ydegp");
			attr(p, "class", "svelte-8ydegp");
			attr(div1, "class", "step-text svelte-8ydegp");
			attr(div2, "class", "step-content svelte-8ydegp");
			attr(div3, "class", "process-step reveal-element svelte-8ydegp");
		},
		m(target, anchor) {
			insert(target, div3, anchor);
			append(div3, div2);
			append(div2, div0);
			append(div0, t0);
			append(div2, t1);
			append(div2, div1);
			append(div1, h3);
			append(h3, t2);
			append(div1, t3);
			append(div1, p);
			append(p, t4);
			append(div3, t5);
		},
		p(ctx, dirty) {
			if (dirty & /*$t*/ 8 && t0_value !== (t0_value = /*step*/ ctx[8].number + "")) set_data(t0, t0_value);
			if (dirty & /*$t*/ 8 && t2_value !== (t2_value = /*step*/ ctx[8].title + "")) set_data(t2, t2_value);
			if (dirty & /*$t*/ 8 && t4_value !== (t4_value = /*step*/ ctx[8].description + "")) set_data(t4, t4_value);
		},
		d(detaching) {
			if (detaching) detach(div3);
		}
	};
}

function create_fragment$3(ctx) {
	let scrolling = false;

	let clear_scrolling = () => {
		scrolling = false;
	};

	let scrolling_timeout;
	let section;
	let div4;
	let h2;
	let t0_value = (/*$t*/ ctx[3].features?.landing?.process?.title || 'Our Implementation Process') + "";
	let t0;
	let t1;
	let p;
	let t2_value = (/*$t*/ ctx[3].features?.landing?.process?.description || 'A proven approach to seamlessly integrate AI into your business') + "";
	let t2;
	let t3;
	let div3;
	let div2;
	let div0;
	let t4;
	let div1;
	let t5;
	let mounted;
	let dispose;
	add_render_callback(/*onwindowscroll*/ ctx[5]);
	let each_value = /*$t*/ ctx[3].features?.landing?.process?.steps || [];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
	}

	return {
		c() {
			section = element("section");
			div4 = element("div");
			h2 = element("h2");
			t0 = text(t0_value);
			t1 = space();
			p = element("p");
			t2 = text(t2_value);
			t3 = space();
			div3 = element("div");
			div2 = element("div");
			div0 = element("div");
			t4 = space();
			div1 = element("div");
			t5 = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(h2, "class", "reveal-element svelte-8ydegp");
			attr(p, "class", "section-description reveal-element svelte-8ydegp");
			attr(div0, "class", "progress-line-bg svelte-8ydegp");
			attr(div1, "class", "progress-line svelte-8ydegp");
			attr(div2, "class", "progress-line-container svelte-8ydegp");
			attr(div3, "class", "process-steps svelte-8ydegp");
			attr(div4, "class", "container");
			attr(section, "id", "process");
			attr(section, "class", "process-section svelte-8ydegp");
		},
		m(target, anchor) {
			insert(target, section, anchor);
			append(section, div4);
			append(div4, h2);
			append(h2, t0);
			append(div4, t1);
			append(div4, p);
			append(p, t2);
			append(div4, t3);
			append(div4, div3);
			append(div3, div2);
			append(div2, div0);
			append(div2, t4);
			append(div2, div1);
			/*div1_binding*/ ctx[6](div1);
			append(div3, t5);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(div3, null);
				}
			}

			/*section_binding*/ ctx[7](section);

			if (!mounted) {
				dispose = listen(window_1$1, "scroll", () => {
					scrolling = true;
					clearTimeout(scrolling_timeout);
					scrolling_timeout = setTimeout(clear_scrolling, 100);
					/*onwindowscroll*/ ctx[5]();
				});

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (dirty & /*scrollY*/ 4 && !scrolling) {
				scrolling = true;
				clearTimeout(scrolling_timeout);
				scrollTo(window_1$1.pageXOffset, /*scrollY*/ ctx[2]);
				scrolling_timeout = setTimeout(clear_scrolling, 100);
			}

			if (dirty & /*$t*/ 8 && t0_value !== (t0_value = (/*$t*/ ctx[3].features?.landing?.process?.title || 'Our Implementation Process') + "")) set_data(t0, t0_value);
			if (dirty & /*$t*/ 8 && t2_value !== (t2_value = (/*$t*/ ctx[3].features?.landing?.process?.description || 'A proven approach to seamlessly integrate AI into your business') + "")) set_data(t2, t2_value);

			if (dirty & /*$t*/ 8) {
				each_value = /*$t*/ ctx[3].features?.landing?.process?.steps || [];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$1(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div3, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(section);
			/*div1_binding*/ ctx[6](null);
			destroy_each(each_blocks, detaching);
			/*section_binding*/ ctx[7](null);
			mounted = false;
			dispose();
		}
	};
}

function instance$3($$self, $$props, $$invalidate) {
	let $t;
	component_subscribe($$self, t, $$value => $$invalidate(3, $t = $$value));
	let { sectionVisible = {} } = $$props;
	let sectionElement;
	let progressLine;
	let scrollY = 0;

	// We no longer need the scroll-based animation since we're using Intersection Observer
	// Add onMount to ensure elements are properly initialized
	onMount(() => {
		// Force a reflow to ensure the reveal elements are properly initialized
		const revealElements = sectionElement.querySelectorAll('.reveal-element');

		console.log('ProcessSection reveal elements:', revealElements.length);

		// Force a reflow to ensure CSS transitions work properly
		revealElements.forEach(el => {
			// This forces a reflow
			void el.offsetHeight;
		});

		// Set up the progress line animation
		const updateProgressLine = () => {
			if (!progressLine || !sectionElement) return;
			const sectionRect = sectionElement.getBoundingClientRect();
			const sectionTop = sectionRect.top;
			const sectionHeight = sectionRect.height;
			const windowHeight = window.innerHeight;

			// Calculate how much of the section is visible
			let progress = 0;

			if (sectionTop <= windowHeight * 0.2) {
				// Start filling when the section top reaches 20% from the top of viewport
				progress = Math.min(1, (windowHeight * 0.2 - sectionTop) / (sectionHeight * 0.8));
			}

			// Update the progress line height
			$$invalidate(1, progressLine.style.height = `${progress * 100}%`, progressLine);
		};

		// Initial update
		updateProgressLine();

		// Add scroll event listener
		window.addEventListener('scroll', updateProgressLine);

		return () => {
			window.removeEventListener('scroll', updateProgressLine);
		};
	});

	function onwindowscroll() {
		$$invalidate(2, scrollY = window_1$1.pageYOffset);
	}

	function div1_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			progressLine = $$value;
			$$invalidate(1, progressLine);
		});
	}

	function section_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			sectionElement = $$value;
			$$invalidate(0, sectionElement);
		});
	}

	$$self.$$set = $$props => {
		if ('sectionVisible' in $$props) $$invalidate(4, sectionVisible = $$props.sectionVisible);
	};

	return [
		sectionElement,
		progressLine,
		scrollY,
		$t,
		sectionVisible,
		onwindowscroll,
		div1_binding,
		section_binding
	];
}

class ProcessSection extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$3, create_fragment$3, safe_not_equal, { sectionVisible: 4 });
	}
}

/* src\landing\LandingComponents\CaseStudiesSection.svelte generated by Svelte v3.59.2 */

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[4] = list[i];
	return child_ctx;
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[7] = list[i];
	return child_ctx;
}

// (31:14) {#each case_study.metrics as metric}
function create_each_block_1(ctx) {
	let li;
	let t_1_value = /*metric*/ ctx[7] + "";
	let t_1;

	return {
		c() {
			li = element("li");
			t_1 = text(t_1_value);
			attr(li, "class", "svelte-plqajz");
		},
		m(target, anchor) {
			insert(target, li, anchor);
			append(li, t_1);
		},
		p(ctx, dirty) {
			if (dirty & /*$t*/ 2 && t_1_value !== (t_1_value = /*metric*/ ctx[7] + "")) set_data(t_1, t_1_value);
		},
		d(detaching) {
			if (detaching) detach(li);
		}
	};
}

// (24:6) {#each ($t.features?.landing?.caseStudies?.cases || []) as case_study}
function create_each_block(ctx) {
	let div1;
	let div0;
	let span;
	let t0_value = /*case_study*/ ctx[4].industry + "";
	let t0;
	let t1;
	let h3;
	let t2_value = /*case_study*/ ctx[4].title + "";
	let t2;
	let t3;
	let p;
	let t4_value = /*case_study*/ ctx[4].description + "";
	let t4;
	let t5;
	let ul;
	let t6;
	let each_value_1 = /*case_study*/ ctx[4].metrics;
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	return {
		c() {
			div1 = element("div");
			div0 = element("div");
			span = element("span");
			t0 = text(t0_value);
			t1 = space();
			h3 = element("h3");
			t2 = text(t2_value);
			t3 = space();
			p = element("p");
			t4 = text(t4_value);
			t5 = space();
			ul = element("ul");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t6 = space();
			attr(span, "class", "industry svelte-plqajz");
			attr(h3, "class", "svelte-plqajz");
			attr(p, "class", "description svelte-plqajz");
			attr(ul, "class", "metrics svelte-plqajz");
			attr(div0, "class", "case-content svelte-plqajz");
			attr(div1, "class", "case-card reveal-element svelte-plqajz");
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, div0);
			append(div0, span);
			append(span, t0);
			append(div0, t1);
			append(div0, h3);
			append(h3, t2);
			append(div0, t3);
			append(div0, p);
			append(p, t4);
			append(div0, t5);
			append(div0, ul);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(ul, null);
				}
			}

			append(div1, t6);
		},
		p(ctx, dirty) {
			if (dirty & /*$t*/ 2 && t0_value !== (t0_value = /*case_study*/ ctx[4].industry + "")) set_data(t0, t0_value);
			if (dirty & /*$t*/ 2 && t2_value !== (t2_value = /*case_study*/ ctx[4].title + "")) set_data(t2, t2_value);
			if (dirty & /*$t*/ 2 && t4_value !== (t4_value = /*case_study*/ ctx[4].description + "")) set_data(t4, t4_value);

			if (dirty & /*$t*/ 2) {
				each_value_1 = /*case_study*/ ctx[4].metrics;
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(ul, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_1.length;
			}
		},
		d(detaching) {
			if (detaching) detach(div1);
			destroy_each(each_blocks, detaching);
		}
	};
}

function create_fragment$2(ctx) {
	let section;
	let div3;
	let h2;
	let t0_value = (/*$t*/ ctx[1].features?.landing?.caseStudies?.title || 'Solutions') + "";
	let t0;
	let t1;
	let p0;
	let t2_value = (/*$t*/ ctx[1].features?.landing?.caseStudies?.description || 'Here are some examples of our solutions:') + "";
	let t2;
	let t3;
	let div2;
	let t4;
	let div1;
	let div0;
	let h3;
	let t5_value = (/*$t*/ ctx[1].features?.landing?.caseStudies?.possibilities?.title || 'Endless Possibilities') + "";
	let t5;
	let t6;
	let p1;
	let t7_value = (/*$t*/ ctx[1].features?.landing?.caseStudies?.possibilities?.conclusion || 'We have identified and designed specific automations internally that we are now ready to implement in our and other businesses.') + "";
	let t7;
	let each_value = /*$t*/ ctx[1].features?.landing?.caseStudies?.cases || [];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	return {
		c() {
			section = element("section");
			div3 = element("div");
			h2 = element("h2");
			t0 = text(t0_value);
			t1 = space();
			p0 = element("p");
			t2 = text(t2_value);
			t3 = space();
			div2 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t4 = space();
			div1 = element("div");
			div0 = element("div");
			h3 = element("h3");
			t5 = text(t5_value);
			t6 = space();
			p1 = element("p");
			t7 = text(t7_value);
			attr(h2, "class", "reveal-element svelte-plqajz");
			attr(p0, "class", "section-description reveal-element svelte-plqajz");
			attr(h3, "class", "svelte-plqajz");
			attr(p1, "class", "possibilities-text svelte-plqajz");
			attr(div0, "class", "case-content svelte-plqajz");
			attr(div1, "class", "case-card possibilities-card reveal-element svelte-plqajz");
			attr(div2, "class", "cases-list svelte-plqajz");
			attr(div3, "class", "container");
			attr(section, "id", "case-studies");
			attr(section, "class", "case-studies-section svelte-plqajz");
		},
		m(target, anchor) {
			insert(target, section, anchor);
			append(section, div3);
			append(div3, h2);
			append(h2, t0);
			append(div3, t1);
			append(div3, p0);
			append(p0, t2);
			append(div3, t3);
			append(div3, div2);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(div2, null);
				}
			}

			append(div2, t4);
			append(div2, div1);
			append(div1, div0);
			append(div0, h3);
			append(h3, t5);
			append(div0, t6);
			append(div0, p1);
			append(p1, t7);
			/*section_binding*/ ctx[3](section);
		},
		p(ctx, [dirty]) {
			if (dirty & /*$t*/ 2 && t0_value !== (t0_value = (/*$t*/ ctx[1].features?.landing?.caseStudies?.title || 'Solutions') + "")) set_data(t0, t0_value);
			if (dirty & /*$t*/ 2 && t2_value !== (t2_value = (/*$t*/ ctx[1].features?.landing?.caseStudies?.description || 'Here are some examples of our solutions:') + "")) set_data(t2, t2_value);

			if (dirty & /*$t*/ 2) {
				each_value = /*$t*/ ctx[1].features?.landing?.caseStudies?.cases || [];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div2, t4);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			if (dirty & /*$t*/ 2 && t5_value !== (t5_value = (/*$t*/ ctx[1].features?.landing?.caseStudies?.possibilities?.title || 'Endless Possibilities') + "")) set_data(t5, t5_value);
			if (dirty & /*$t*/ 2 && t7_value !== (t7_value = (/*$t*/ ctx[1].features?.landing?.caseStudies?.possibilities?.conclusion || 'We have identified and designed specific automations internally that we are now ready to implement in our and other businesses.') + "")) set_data(t7, t7_value);
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(section);
			destroy_each(each_blocks, detaching);
			/*section_binding*/ ctx[3](null);
		}
	};
}

function instance$2($$self, $$props, $$invalidate) {
	let $t;
	component_subscribe($$self, t, $$value => $$invalidate(1, $t = $$value));
	let { sectionVisible = {} } = $$props;
	let sectionElement;

	// We no longer need the scroll-based animation since we're using Intersection Observer
	// Add onMount to ensure elements are properly initialized
	onMount(() => {
		if (sectionElement) {
			const revealElements = sectionElement.querySelectorAll('.reveal-element');
			console.log('CaseStudiesSection reveal elements:', revealElements.length);

			revealElements.forEach(el => {
				void el.offsetHeight;
			});
		}
	});

	function section_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			sectionElement = $$value;
			$$invalidate(0, sectionElement);
		});
	}

	$$self.$$set = $$props => {
		if ('sectionVisible' in $$props) $$invalidate(2, sectionVisible = $$props.sectionVisible);
	};

	return [sectionElement, $t, sectionVisible, section_binding];
}

class CaseStudiesSection extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$2, create_fragment$2, safe_not_equal, { sectionVisible: 2 });
	}
}

/* src\landing\LandingComponents\CtaSection.svelte generated by Svelte v3.59.2 */

function create_fragment$1(ctx) {
	let section;
	let div1;
	let h2;
	let t0_value = (/*$t*/ ctx[2].features?.landing?.cta?.title || 'Ready to Transform Your Business?') + "";
	let t0;
	let t1;
	let p;
	let t2_value = (/*$t*/ ctx[2].features?.landing?.cta?.description || 'Schedule a free consultation to discuss how AI automation can address your specific business challenges') + "";
	let t2;
	let t3;
	let div0;
	let a;
	let t4_value = (/*$t*/ ctx[2].features?.landing?.cta?.primaryButton || 'Contact Us') + "";
	let t4;

	return {
		c() {
			section = element("section");
			div1 = element("div");
			h2 = element("h2");
			t0 = text(t0_value);
			t1 = space();
			p = element("p");
			t2 = text(t2_value);
			t3 = space();
			div0 = element("div");
			a = element("a");
			t4 = text(t4_value);
			attr(h2, "class", "reveal-element svelte-1ktfn03");
			attr(p, "class", "cta-description reveal-element svelte-1ktfn03");
			attr(a, "href", "/landing/contact/");
			attr(a, "class", "btn btn-primary svelte-1ktfn03");
			attr(div0, "class", "cta-buttons reveal-element svelte-1ktfn03");
			attr(div1, "class", "container svelte-1ktfn03");
			attr(section, "id", "cta");
			attr(section, "class", "cta-section svelte-1ktfn03");
			toggle_class(section, "visible", /*sectionVisible*/ ctx[0]['cta'] || false);
		},
		m(target, anchor) {
			insert(target, section, anchor);
			append(section, div1);
			append(div1, h2);
			append(h2, t0);
			append(div1, t1);
			append(div1, p);
			append(p, t2);
			append(div1, t3);
			append(div1, div0);
			append(div0, a);
			append(a, t4);
			/*section_binding*/ ctx[3](section);
		},
		p(ctx, [dirty]) {
			if (dirty & /*$t*/ 4 && t0_value !== (t0_value = (/*$t*/ ctx[2].features?.landing?.cta?.title || 'Ready to Transform Your Business?') + "")) set_data(t0, t0_value);
			if (dirty & /*$t*/ 4 && t2_value !== (t2_value = (/*$t*/ ctx[2].features?.landing?.cta?.description || 'Schedule a free consultation to discuss how AI automation can address your specific business challenges') + "")) set_data(t2, t2_value);
			if (dirty & /*$t*/ 4 && t4_value !== (t4_value = (/*$t*/ ctx[2].features?.landing?.cta?.primaryButton || 'Contact Us') + "")) set_data(t4, t4_value);

			if (dirty & /*sectionVisible*/ 1) {
				toggle_class(section, "visible", /*sectionVisible*/ ctx[0]['cta'] || false);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(section);
			/*section_binding*/ ctx[3](null);
		}
	};
}

function instance$1($$self, $$props, $$invalidate) {
	let $t;
	component_subscribe($$self, t, $$value => $$invalidate(2, $t = $$value));
	let { sectionVisible = {} } = $$props;
	let sectionElement;

	// We no longer need the scroll-based animation since we're using Intersection Observer
	// Add onMount to ensure elements are properly initialized
	onMount(() => {
		// Make sure sectionElement is defined before trying to use it
		if (sectionElement) {
			// Force a reflow to ensure the reveal elements are properly initialized
			const revealElements = sectionElement.querySelectorAll('.reveal-element');

			console.log('CtaSection reveal elements:', revealElements.length);

			// Force a reflow to ensure CSS transitions work properly
			revealElements.forEach(el => {
				// This forces a reflow
				void el.offsetHeight;
			});
		}
	});

	function section_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			sectionElement = $$value;
			$$invalidate(1, sectionElement);
		});
	}

	$$self.$$set = $$props => {
		if ('sectionVisible' in $$props) $$invalidate(0, sectionVisible = $$props.sectionVisible);
	};

	return [sectionVisible, sectionElement, $t, section_binding];
}

class CtaSection extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$1, create_fragment$1, safe_not_equal, { sectionVisible: 0 });
	}
}

/* src\landing\Landing.svelte generated by Svelte v3.59.2 */

const { document: document_1, setTimeout: setTimeout_1, window: window_1 } = globals;

function create_fragment(ctx) {
	let scrolling = false;

	let clear_scrolling = () => {
		scrolling = false;
	};

	let scrolling_timeout;
	let title_value;
	let meta;
	let meta_content_value;
	let link;
	let t0;
	let div7;
	let publicnavbar;
	let t1;
	let div6;
	let div1;
	let div0;
	let herosection;
	let t2;
	let div2;
	let benefitssection;
	let t3;
	let div3;
	let processsection;
	let t4;
	let div4;
	let casestudiessection;
	let t5;
	let div5;
	let ctasection;
	let t6;
	let footer;
	let current;
	let mounted;
	let dispose;
	add_render_callback(/*onwindowscroll*/ ctx[3]);
	document_1.title = title_value = /*$t*/ ctx[2].features?.landing?.meta?.title || 'AI Automation Solutions for Businesses | Yekar';
	publicnavbar = new PublicNavbar({ props: { currentPage: "landing" } });

	herosection = new HeroSection({
			props: {
				sectionVisible: /*sectionVisible*/ ctx[0]
			}
		});

	benefitssection = new BenefitsSection({
			props: {
				sectionVisible: /*sectionVisible*/ ctx[0]
			}
		});

	processsection = new ProcessSection({
			props: {
				sectionVisible: /*sectionVisible*/ ctx[0]
			}
		});

	casestudiessection = new CaseStudiesSection({
			props: {
				sectionVisible: /*sectionVisible*/ ctx[0]
			}
		});

	ctasection = new CtaSection({
			props: {
				sectionVisible: /*sectionVisible*/ ctx[0]
			}
		});

	footer = new Footer({});

	return {
		c() {
			meta = element("meta");
			link = element("link");
			t0 = space();
			div7 = element("div");
			create_component(publicnavbar.$$.fragment);
			t1 = space();
			div6 = element("div");
			div1 = element("div");
			div0 = element("div");
			create_component(herosection.$$.fragment);
			t2 = space();
			div2 = element("div");
			create_component(benefitssection.$$.fragment);
			t3 = space();
			div3 = element("div");
			create_component(processsection.$$.fragment);
			t4 = space();
			div4 = element("div");
			create_component(casestudiessection.$$.fragment);
			t5 = space();
			div5 = element("div");
			create_component(ctasection.$$.fragment);
			t6 = space();
			create_component(footer.$$.fragment);
			attr(meta, "name", "description");
			attr(meta, "content", meta_content_value = /*$t*/ ctx[2].features?.landing?.meta?.description || 'Transform your business operations with our AI automation solutions. Increase efficiency, reduce costs, and improve customer experience with Yekar.');
			attr(link, "href", "https://fonts.googleapis.com/css2?family=Montserrat:wght@900&family=Roboto:wght@400;700&display=swap");
			attr(link, "rel", "stylesheet");
			attr(div0, "class", "hero-parallax svelte-131651o");
			attr(div0, "data-speed", "0.05");
			attr(div0, "data-direction", "up");
			attr(div1, "class", "parallax-wrapper svelte-131651o");
			attr(div2, "class", "regular-section svelte-131651o");
			attr(div3, "class", "regular-section svelte-131651o");
			attr(div4, "class", "regular-section svelte-131651o");
			attr(div5, "class", "regular-section svelte-131651o");
			attr(div6, "class", "content-wrapper svelte-131651o");
			attr(div7, "class", "landing-page svelte-131651o");
			toggle_class(div7, "debug-mode", debugMode);
		},
		m(target, anchor) {
			append(document_1.head, meta);
			append(document_1.head, link);
			insert(target, t0, anchor);
			insert(target, div7, anchor);
			mount_component(publicnavbar, div7, null);
			append(div7, t1);
			append(div7, div6);
			append(div6, div1);
			append(div1, div0);
			mount_component(herosection, div0, null);
			append(div6, t2);
			append(div6, div2);
			mount_component(benefitssection, div2, null);
			append(div6, t3);
			append(div6, div3);
			mount_component(processsection, div3, null);
			append(div6, t4);
			append(div6, div4);
			mount_component(casestudiessection, div4, null);
			append(div6, t5);
			append(div6, div5);
			mount_component(ctasection, div5, null);
			append(div7, t6);
			mount_component(footer, div7, null);
			current = true;

			if (!mounted) {
				dispose = listen(window_1, "scroll", () => {
					scrolling = true;
					clearTimeout(scrolling_timeout);
					scrolling_timeout = setTimeout_1(clear_scrolling, 100);
					/*onwindowscroll*/ ctx[3]();
				});

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (dirty & /*scrollY*/ 2 && !scrolling) {
				scrolling = true;
				clearTimeout(scrolling_timeout);
				scrollTo(window_1.pageXOffset, /*scrollY*/ ctx[1]);
				scrolling_timeout = setTimeout_1(clear_scrolling, 100);
			}

			if ((!current || dirty & /*$t*/ 4) && title_value !== (title_value = /*$t*/ ctx[2].features?.landing?.meta?.title || 'AI Automation Solutions for Businesses | Yekar')) {
				document_1.title = title_value;
			}

			if (!current || dirty & /*$t*/ 4 && meta_content_value !== (meta_content_value = /*$t*/ ctx[2].features?.landing?.meta?.description || 'Transform your business operations with our AI automation solutions. Increase efficiency, reduce costs, and improve customer experience with Yekar.')) {
				attr(meta, "content", meta_content_value);
			}

			const herosection_changes = {};
			if (dirty & /*sectionVisible*/ 1) herosection_changes.sectionVisible = /*sectionVisible*/ ctx[0];
			herosection.$set(herosection_changes);
			const benefitssection_changes = {};
			if (dirty & /*sectionVisible*/ 1) benefitssection_changes.sectionVisible = /*sectionVisible*/ ctx[0];
			benefitssection.$set(benefitssection_changes);
			const processsection_changes = {};
			if (dirty & /*sectionVisible*/ 1) processsection_changes.sectionVisible = /*sectionVisible*/ ctx[0];
			processsection.$set(processsection_changes);
			const casestudiessection_changes = {};
			if (dirty & /*sectionVisible*/ 1) casestudiessection_changes.sectionVisible = /*sectionVisible*/ ctx[0];
			casestudiessection.$set(casestudiessection_changes);
			const ctasection_changes = {};
			if (dirty & /*sectionVisible*/ 1) ctasection_changes.sectionVisible = /*sectionVisible*/ ctx[0];
			ctasection.$set(ctasection_changes);
		},
		i(local) {
			if (current) return;
			transition_in(publicnavbar.$$.fragment, local);
			transition_in(herosection.$$.fragment, local);
			transition_in(benefitssection.$$.fragment, local);
			transition_in(processsection.$$.fragment, local);
			transition_in(casestudiessection.$$.fragment, local);
			transition_in(ctasection.$$.fragment, local);
			transition_in(footer.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(publicnavbar.$$.fragment, local);
			transition_out(herosection.$$.fragment, local);
			transition_out(benefitssection.$$.fragment, local);
			transition_out(processsection.$$.fragment, local);
			transition_out(casestudiessection.$$.fragment, local);
			transition_out(ctasection.$$.fragment, local);
			transition_out(footer.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			detach(meta);
			detach(link);
			if (detaching) detach(t0);
			if (detaching) detach(div7);
			destroy_component(publicnavbar);
			destroy_component(herosection);
			destroy_component(benefitssection);
			destroy_component(processsection);
			destroy_component(casestudiessection);
			destroy_component(ctasection);
			destroy_component(footer);
			mounted = false;
			dispose();
		}
	};
}

let debugMode = false;

function instance($$self, $$props, $$invalidate) {
	let $t;
	component_subscribe($$self, t, $$value => $$invalidate(2, $t = $$value));
	let sectionVisible = {};
	let scrollY;

	onMount(() => {
		// Add a small delay to ensure all components are fully rendered
		setTimeout(
			() => {
				// First, make sure all reveal elements have the initial state properly set
				const allRevealElements = document.querySelectorAll('.reveal-element');

				console.log('Total reveal elements found:', allRevealElements.length);

				// Force a reflow on all elements to ensure CSS transitions work properly
				allRevealElements.forEach(el => {
					// Reset any existing visible class that might have been applied
					el.classList.remove('visible');

					// Force a reflow
					void el.offsetHeight;
				});

				// Now set up the intersection observer
				const elementObserver = new IntersectionObserver(entries => {
						entries.forEach(entry => {
							if (entry.isIntersecting) {
								// Add visible class to the element
								entry.target.classList.add('visible');

								console.log('Element visible:', entry.target);
							}
						});
					},
				{
						threshold: 0.1,
						rootMargin: '0px 0px -50px 0px'
					});

				// Observe all elements with the 'reveal-element' class
				allRevealElements.forEach(element => {
					elementObserver.observe(element);

					// Check if element is already in viewport and make it visible immediately
					const rect = element.getBoundingClientRect();

					if (rect.top < window.innerHeight) {
						element.classList.add('visible');
					}
				});

				// Section visibility for component-level animations (keep for backward compatibility)
				const sectionObserver = new IntersectionObserver(entries => {
						entries.forEach(entry => {
							if (entry.isIntersecting) {
								$$invalidate(0, sectionVisible[entry.target.id] = true, sectionVisible);
							}
						});
					},
				{ threshold: 0.1 });

				document.querySelectorAll('section').forEach(section => {
					sectionObserver.observe(section);
				});
			},
			300
		); // Increased delay to ensure DOM is ready

		// Set up parallax effect ONLY for the hero section
		const heroParallaxElements = document.querySelectorAll('.hero-parallax');

		const handleScroll = () => {
			heroParallaxElements.forEach(element => {
				const speedMultiplier = parseFloat(element.dataset.speed || '0.5');

				// Limit the maximum offset to prevent elements from overlapping too much
				const maxOffset = 80; // Reduced from 100 to ensure less overlap

				const offset = Math.min(maxOffset, window.scrollY * speedMultiplier);

				// Apply transform based on element's data-direction (up/down)
				if (element.dataset.direction === 'up') {
					element.style.transform = `translateY(-${offset}px)`;
				} else {
					element.style.transform = `translateY(${offset}px)`;
				}
			});
		};

		window.addEventListener('scroll', handleScroll);

		return () => {
			window.removeEventListener('scroll', handleScroll);
		};
	});

	function onwindowscroll() {
		$$invalidate(1, scrollY = window_1.pageYOffset);
	}

	return [sectionVisible, scrollY, $t, onwindowscroll];
}

class Landing extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, {});
	}
}

new Landing({
    target: document.body,
});
//# sourceMappingURL=landing.js.map
